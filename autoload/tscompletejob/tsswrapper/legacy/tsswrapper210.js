exports.start = function (tsslib) {

    const ts = require(tsslib)
    const server = ts.server;

    // ================ __extends function  generated by typescript ============
    var __extends = (this && this.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    // ===================== START from tsserver.js ===================
    var net = require("net");
    var childProcess = require("child_process");
    var os = require("os");
    function getGlobalTypingsCacheLocation() {
        switch (process.platform) {
            case "win32": {
                var basePath = process.env.LOCALAPPDATA ||
                process.env.APPDATA ||
                (os.homedir && os.homedir()) ||
                process.env.USERPROFILE ||
                (process.env.HOMEDRIVE && process.env.HOMEPATH && ts.normalizeSlashes(process.env.HOMEDRIVE + process.env.HOMEPATH)) ||
                os.tmpdir();
                return ts.combinePaths(ts.normalizeSlashes(basePath), "Microsoft/TypeScript");
            }
            case "darwin":
            case "linux":
            case "android": {
                var cacheLocation = getNonWindowsCacheLocation(process.platform === "darwin");
                return ts.combinePaths(cacheLocation, "typescript");
            }
            default:
                ts.Debug.fail("unsupported platform '" + process.platform + "'");
                return;
        }
    }
    function getNonWindowsCacheLocation(platformIsDarwin) {
        if (process.env.XDG_CACHE_HOME) {
            return process.env.XDG_CACHE_HOME;
        }
        var usersDir = platformIsDarwin ? "Users" : "home";
        var homePath = (os.homedir && os.homedir()) ||
            process.env.HOME ||
            ((process.env.LOGNAME || process.env.USER) && "/" + usersDir + "/" + (process.env.LOGNAME || process.env.USER)) ||
            os.tmpdir();
        var cacheFolder = platformIsDarwin
            ? "Library/Caches"
            : ".cache";
        return ts.combinePaths(ts.normalizeSlashes(homePath), cacheFolder);
    }
    var readline = require("readline");
    var fs = require("fs");
    var rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
        terminal: false,
    });
    var Logger = (function () {
        function Logger(logFilename, traceToConsole, level) {
            this.logFilename = logFilename;
            this.traceToConsole = traceToConsole;
            this.level = level;
            this.fd = -1;
            this.seq = 0;
            this.inGroup = false;
            this.firstInGroup = true;
        }
        Logger.padStringRight = function (str, padding) {
            return (str + padding).slice(0, padding.length);
        };
        Logger.prototype.close = function () {
            if (this.fd >= 0) {
                fs.close(this.fd);
            }
        };
        Logger.prototype.getLogFileName = function () {
            return this.logFilename;
        };
        Logger.prototype.perftrc = function (s) {
            this.msg(s, server.Msg.Perf);
        };
        Logger.prototype.info = function (s) {
            this.msg(s, server.Msg.Info);
        };
        Logger.prototype.startGroup = function () {
            this.inGroup = true;
            this.firstInGroup = true;
        };
        Logger.prototype.endGroup = function () {
            this.inGroup = false;
            this.seq++;
            this.firstInGroup = true;
        };
        Logger.prototype.loggingEnabled = function () {
            return !!this.logFilename || this.traceToConsole;
        };
        Logger.prototype.hasLevel = function (level) {
            return this.loggingEnabled() && this.level >= level;
        };
        Logger.prototype.msg = function (s, type) {
            if (type === void 0) { type = server.Msg.Err; }
            if (this.fd < 0) {
                if (this.logFilename) {
                    this.fd = fs.openSync(this.logFilename, "w");
                }
            }
            if (this.fd >= 0 || this.traceToConsole) {
                s = s + "\n";
                var prefix = Logger.padStringRight(type + " " + this.seq.toString(), "          ");
                if (this.firstInGroup) {
                    s = prefix + s;
                    this.firstInGroup = false;
                }
                if (!this.inGroup) {
                    this.seq++;
                    this.firstInGroup = true;
                }
                if (this.fd >= 0) {
                    var buf = new Buffer(s);
                    fs.writeSync(this.fd, buf, 0, buf.length, null);
                }
                if (this.traceToConsole) {
                    console.warn(s);
                }
            }
        };
        return Logger;
    }());
    var NodeTypingsInstaller = (function () {
        function NodeTypingsInstaller(telemetryEnabled, logger, host, eventPort, globalTypingsCacheLocation, newLine) {
            var _this = this;
            this.telemetryEnabled = telemetryEnabled;
            this.logger = logger;
            this.globalTypingsCacheLocation = globalTypingsCacheLocation;
            this.newLine = newLine;
            this.installerPidReported = false;
            this.throttledOperations = new server.ThrottledOperations(host);
            if (eventPort) {
                var s_1 = net.connect({ port: eventPort }, function () {
                    _this.socket = s_1;
                    _this.reportInstallerProcessId();
                });
            }
        }
        NodeTypingsInstaller.prototype.reportInstallerProcessId = function () {
            if (this.installerPidReported) {
                return;
            }
            if (this.socket && this.installer) {
                this.sendEvent(0, "typingsInstallerPid", { pid: this.installer.pid });
                this.installerPidReported = true;
            }
        };
        NodeTypingsInstaller.prototype.sendEvent = function (seq, event, body) {
            this.socket.write(server.formatMessage({ seq: seq, type: "event", event: event, body: body }, this.logger, Buffer.byteLength, this.newLine), "utf8");
        };
        NodeTypingsInstaller.prototype.setTelemetrySender = function (telemetrySender) {
            this.eventSender = telemetrySender;
        };
        NodeTypingsInstaller.prototype.attach = function (projectService) {
            var _this = this;
            this.projectService = projectService;
            if (this.logger.hasLevel(server.LogLevel.requestTime)) {
                this.logger.info("Binding...");
            }
            var args = [server.Arguments.GlobalCacheLocation, this.globalTypingsCacheLocation];
            if (this.telemetryEnabled) {
                args.push(server.Arguments.EnableTelemetry);
            }
            if (this.logger.loggingEnabled() && this.logger.getLogFileName()) {
                args.push(server.Arguments.LogFile, ts.combinePaths(ts.getDirectoryPath(ts.normalizeSlashes(this.logger.getLogFileName())), "ti-" + process.pid + ".log"));
            }
            var execArgv = [];
            {
                for (var _i = 0, _a = process.execArgv; _i < _a.length; _i++) {
                    var arg = _a[_i];
                    var match = /^--(debug|inspect)(=(\d+))?$/.exec(arg);
                    if (match) {
                        var currentPort = match[3] !== undefined
                            ? +match[3]
                            : match[1] === "debug" ? 5858 : 9229;
                        execArgv.push("--" + match[1] + "=" + (currentPort + 1));
                        break;
                    }
                }
            }
            this.installer = childProcess.fork(ts.combinePaths(__dirname, "node_modules/typescript/lib/typingsInstaller.js"), args, { execArgv: execArgv });
            this.installer.on("message", function (m) { return _this.handleMessage(m); });
            this.reportInstallerProcessId();
            process.on("exit", function () {
                _this.installer.kill();
            });
        };
        NodeTypingsInstaller.prototype.onProjectClosed = function (p) {
            this.installer.send({ projectName: p.getProjectName(), kind: "closeProject" });
        };
        NodeTypingsInstaller.prototype.enqueueInstallTypingsRequest = function (project, typeAcquisition, unresolvedImports) {
            var _this = this;
            var request = server.createInstallTypingsRequest(project, typeAcquisition, unresolvedImports);
            if (this.logger.hasLevel(server.LogLevel.verbose)) {
                if (this.logger.hasLevel(server.LogLevel.verbose)) {
                    this.logger.info("Scheduling throttled operation: " + JSON.stringify(request));
                }
            }
            this.throttledOperations.schedule(project.getProjectName(), 250, function () {
                if (_this.logger.hasLevel(server.LogLevel.verbose)) {
                    _this.logger.info("Sending request: " + JSON.stringify(request));
                }
                _this.installer.send(request);
            });
        };
        NodeTypingsInstaller.prototype.handleMessage = function (response) {
            if (this.logger.hasLevel(server.LogLevel.verbose)) {
                this.logger.info("Received response: " + JSON.stringify(response));
            }
            if (response.kind === server.EventBeginInstallTypes) {
                if (!this.eventSender) {
                    return;
                }
                var body = {
                    eventId: response.eventId,
                    packages: response.packagesToInstall,
                };
                var eventName = "beginInstallTypes";
                this.eventSender.event(body, eventName);
                return;
            }
            if (response.kind === server.EventEndInstallTypes) {
                if (!this.eventSender) {
                    return;
                }
                if (this.telemetryEnabled) {
                    var body_1 = {
                        telemetryEventName: "typingsInstalled",
                        payload: {
                            installedPackages: response.packagesToInstall.join(","),
                            installSuccess: response.installSuccess,
                            typingsInstallerVersion: response.typingsInstallerVersion
                        }
                    };
                    var eventName_1 = "telemetry";
                    this.eventSender.event(body_1, eventName_1);
                }
                var body = {
                    eventId: response.eventId,
                    packages: response.packagesToInstall,
                    success: response.installSuccess,
                };
                var eventName = "endInstallTypes";
                this.eventSender.event(body, eventName);
                return;
            }
            this.projectService.updateTypingsForProject(response);
            if (response.kind == server.ActionSet && this.socket) {
                this.sendEvent(0, "setTypings", response);
            }
        };
        return NodeTypingsInstaller;
    }());
    var IOSession = (function (_super) {
        __extends(IOSession, _super);
        function IOSession(host, cancellationToken, installerEventPort, canUseEvents, useSingleInferredProject, disableAutomaticTypingAcquisition, globalTypingsCacheLocation, telemetryEnabled, logger) {
            var _this = this;
            var typingsInstaller = disableAutomaticTypingAcquisition
                ? undefined
                : new NodeTypingsInstaller(telemetryEnabled, logger, host, installerEventPort, globalTypingsCacheLocation, host.newLine);
            _this = _super.call(this, host, cancellationToken, useSingleInferredProject, typingsInstaller || server.nullTypingsInstaller, Buffer.byteLength, process.hrtime, logger, canUseEvents) || this;
            if (telemetryEnabled && typingsInstaller) {
                typingsInstaller.setTelemetrySender(_this);
            }
            return _this;
        }
        IOSession.prototype.exit = function () {
            this.logger.info("Exiting...");
            this.projectService.closeLog();
            process.exit(0);
        };
        IOSession.prototype.listen = function () {
            var _this = this;
            rl.on("line", function (input) {
                var message = input.trim();
                _this.onMessage(message);
            });
            rl.on("close", function () {
                _this.exit();
            });
        };
        return IOSession;
    }(server.Session));
    function parseLoggingEnvironmentString(logEnvStr) {
        var logEnv = { logToFile: true };
        var args = logEnvStr.split(" ");
        var len = args.length - 1;
        for (var i = 0; i < len; i += 2) {
            var option = args[i];
            var value = args[i + 1];
            if (option && value) {
                switch (option) {
                    case "-file":
                        logEnv.file = ts.stripQuotes(value);
                        break;
                    case "-level":
                        var level = server.LogLevel[value];
                        logEnv.detailLevel = typeof level === "number" ? level : server.LogLevel.normal;
                        break;
                    case "-traceToConsole":
                        logEnv.traceToConsole = value.toLowerCase() === "true";
                        break;
                    case "-logToFile":
                        logEnv.logToFile = value.toLowerCase() === "true";
                        break;
                }
            }
        }
        return logEnv;
    }
    function createLoggerFromEnv() {
        var fileName = undefined;
        var detailLevel = server.LogLevel.normal;
        var traceToConsole = false;
        var logEnvStr = process.env["TSS_LOG"];
        if (logEnvStr) {
            var logEnv = parseLoggingEnvironmentString(logEnvStr);
            if (logEnv.logToFile) {
                if (logEnv.file) {
                    fileName = logEnv.file;
                }
                else {
                    fileName = __dirname + "/.log" + process.pid.toString();
                }
            }
            if (logEnv.detailLevel) {
                detailLevel = logEnv.detailLevel;
            }
            traceToConsole = logEnv.traceToConsole;
        }
        return new Logger(fileName, traceToConsole, detailLevel);
    }
    function createPollingWatchedFileSet(interval, chunkSize) {
        if (interval === void 0) { interval = 2500; }
        if (chunkSize === void 0) { chunkSize = 30; }
        var watchedFiles = [];
        var nextFileToCheck = 0;
        var watchTimer;
        function getModifiedTime(fileName) {
            return fs.statSync(fileName).mtime;
        }
        function poll(checkedIndex) {
            var watchedFile = watchedFiles[checkedIndex];
            if (!watchedFile) {
                return;
            }
            fs.stat(watchedFile.fileName, function (err, stats) {
                if (err) {
                    watchedFile.callback(watchedFile.fileName);
                }
                else if (watchedFile.mtime.getTime() !== stats.mtime.getTime()) {
                    watchedFile.mtime = getModifiedTime(watchedFile.fileName);
                    watchedFile.callback(watchedFile.fileName, watchedFile.mtime.getTime() === 0);
                }
            });
        }
        function startWatchTimer() {
            watchTimer = setInterval(function () {
                var count = 0;
                var nextToCheck = nextFileToCheck;
                var firstCheck = -1;
                while ((count < chunkSize) && (nextToCheck !== firstCheck)) {
                    poll(nextToCheck);
                    if (firstCheck < 0) {
                        firstCheck = nextToCheck;
                    }
                    nextToCheck++;
                    if (nextToCheck === watchedFiles.length) {
                        nextToCheck = 0;
                    }
                    count++;
                }
                nextFileToCheck = nextToCheck;
            }, interval);
        }
        function addFile(fileName, callback) {
            var file = {
                fileName: fileName,
                callback: callback,
                mtime: getModifiedTime(fileName)
            };
            watchedFiles.push(file);
            if (watchedFiles.length === 1) {
                startWatchTimer();
            }
            return file;
        }
        function removeFile(file) {
            ts.unorderedRemoveItem(watchedFiles, file);
        }
        return {
            getModifiedTime: getModifiedTime,
            poll: poll,
            startWatchTimer: startWatchTimer,
            addFile: addFile,
            removeFile: removeFile
        };
    }
    var pollingWatchedFileSet = createPollingWatchedFileSet();
    var logger = createLoggerFromEnv();
    var pending = [];
    var canWrite = true;
    function writeMessage(buf) {
        if (!canWrite) {
            pending.push(buf);
        }
        else {
            canWrite = false;
            process.stdout.write(buf, setCanWriteFlagAndWriteMessageIfNecessary);
        }
    }
    function setCanWriteFlagAndWriteMessageIfNecessary() {
        canWrite = true;
        if (pending.length) {
            writeMessage(pending.shift());
        }
    }

    function startTsServer(extend) { // *** ADDED ***
        var sys = ts.sys;
        sys.write = function (s) { return writeMessage(new Buffer(s, "utf8")); };
        sys.watchFile = function (fileName, callback) {
            var watchedFile = pollingWatchedFileSet.addFile(fileName, callback);
            return {
                close: function () { return pollingWatchedFileSet.removeFile(watchedFile); }
            };
        };
        sys.setTimeout = setTimeout;
        sys.clearTimeout = clearTimeout;
        sys.setImmediate = setImmediate;
        sys.clearImmediate = clearImmediate;
        if (typeof global !== "undefined" && global.gc) {
            sys.gc = function () { return global.gc(); };
        }
        var cancellationToken;
        try {
            var factory = require("./cancellationToken");
            cancellationToken = factory(sys.args);
        }
        catch (e) {
            cancellationToken = {
                isCancellationRequested: function () { return false; }
            };
        }
        ;
        var eventPort;
        {
            var str = server.findArgument("--eventPort");
            var v = str && parseInt(str);
            if (!isNaN(v)) {
                eventPort = v;
            }
        }
        var localeStr = server.findArgument("--locale");
        if (localeStr) {
            ts.validateLocaleAndSetLanguage(localeStr, sys);
        }
        var useSingleInferredProject = server.hasArgument("--useSingleInferredProject");
        var disableAutomaticTypingAcquisition = server.hasArgument("--disableAutomaticTypingAcquisition");
        var telemetryEnabled = server.hasArgument(server.Arguments.EnableTelemetry);
        var ioSession = new IOSession(sys, cancellationToken, eventPort, eventPort === undefined, useSingleInferredProject, disableAutomaticTypingAcquisition, getGlobalTypingsCacheLocation(), telemetryEnabled, logger);
        process.on("uncaughtException", function (err) {
            ioSession.logError(err, "unknown");
        });
        process.noAsar = true;
        extend(ioSession); // *** ADDED ***
        ioSession.listen();
    } // *** ADDED ***

    // ====================== *** END from tsserver.js *** ===================

    if (!os) { var os = require("os"); }

    startTsServer(function (server) {

        var buildDocumentation = function(dispParts, docs) {
            if(!dispParts && !docs) {
                return undefined;
            }

            var menu;
            if (dispParts) {
                menu = dispParts.reduce(function(s, part) {
                    if (part.kind != "lineBreak") {
                        s += part.text;
                    }
                    return s;
                }, "");
                menu = menu.replace(/\(\w+\)\s*/, "");
            }

            var info;
            if (docs) {
                info = docs.reduce(function(s, doc) {
                    s += "\n" + doc.text;
                    return s;
                }, menu ? menu : "");
            }

            return {
                menu: menu,
                info: info
            };
        };

        function appendDisplayText(s, displayPart) {
            return s + displayPart.text;
        }

        server.addProtocolHandler("completionsForVim", function (request) {
            var args = request.arguments;
            var completions = server.getCompletions(args, true);

            var prefixLength = args.prefix.length;
            var filtered = completions.filter(function (item) { return args.prefix === item.name.substr(0, prefixLength)});

            var enableDetail = args.enableDetail && filtered.length < args.maxDetailCount;

            var detailsMap = {};
            if (enableDetail) {
                completions = filtered;
                var entryNames = completions.map(function (item) { return item.name; });
                var detail_args = {
                    line: args.line,
                    offset: args.offset,
                    file: args.file,
                    entryNames: entryNames,
                };
                var details = server.getCompletionEntryDetails(detail_args);
                var detailsMap = details.reduce(function (map, item) {
                    var docs = buildDocumentation(item.displayParts, item.documentation)
                    if (docs) {
                        map[item.name] = {
                            menu: docs.menu,
                            info: docs.info
                        }
                    }
                    return map;
                }, {});
            }

            var results = completions.map(function (item) {
                var result = { };
                result.word = item.name;
                result.kind = enableDetail ? item.kind.substr(0,1) : item.kind;

                var details = detailsMap[item.name];
                if (details) {
                    result.menu = details.menu;
                    result.info = details.info;
                }
                return result;
            });

            return {
                response: results,
                responseRequired: true
            };
        });

        function buildSignatureHelp(disableDocumentation){
            return function(item) {
                var prefix = item.prefixDisplayParts.reduce(appendDisplayText, "");
                var suffix = item.suffixDisplayParts.reduce(appendDisplayText, "");
                var separator = item.separatorDisplayParts.reduce(appendDisplayText, "");
                var params = item.parameters.reduce(function(acc, param) {
                    var dispText = param.displayParts.reduce(appendDisplayText, "");
                    var docText = param.documentation.reduce(appendDisplayText, "");
                    acc[0].push(dispText);
                    acc[1].push(docText ? param.name + ": " + docText : "");
                    return acc;
                }, [[],[]]);

                var sigDoc = item.documentation.reduce(appendDisplayText, "");

                var abbr = prefix + params[0].join(separator) + suffix;
                var info = (sigDoc + "\n" + params[1].join("\n")).trim();

                return {
                    word: "",
                    abbr: abbr,
                    empty: true,
                    info: disableDocumentation === true ? undefined : info,
                    dup: true,
                };
            }
        }

        server.addProtocolHandler("signatureHelpForVim", function(request) {
            var args = request.arguments;

            var help = server.getSignatureHelpItems(args, true);
            if (!help || !help.items || help.items.length == 0) {
                return { response: "", responseRequired: true };
            }

            var onlyMatched = args.onlyMatched !== false;
            var items = help.items;
            if (onlyMatched) {
                var argCount = help.argumentCount;
                items = items.filter(function(item) { return item.parameters.length >= argCount; });
            }
            var helps = items.map(buildSignatureHelp(args.disableDocumentation));

            return {
                response: helps,
                responseRequired: true
            };
        });

        server.addProtocolHandler("qfixlistForVim", function(request) {
            var args = request.arguments;

            var syntacticDiagnostics = server.getSyntacticDiagnosticsSync(args);
            var semanticDiagnostics = server.getSemanticDiagnosticsSync(args);

            var diags = [].concat(syntacticDiagnostics, semanticDiagnostics);
            var qfixlist = diags.map(function (diag) {
                return {
                    lnum : diag.start.line,
                    col : diag.start.offset,
                    text : diag.text,
                    valid : 1,
                    filename : args.file,
                };
            });

            return {
                response: qfixlist,
                responseRequired: true,
            };
        });

        server.addProtocolHandler("referencesForVim", function(request) {
            var args = request.arguments;

            var refs = server.getReferences(args, true);
            if (refs) {
                var items = refs.refs.sort(function(i1, i2) {
                    return i2.isDefinition - i1.isDefinition;
                });
                var loclist = items.map(function(item) {
                    return item.file + ":" + item.start.line + ":" +
                        item.start.offset + ":" + item.lineText;
                });
                return { response: loclist, responseRequired: true };
            }
            else {
                return { response: [], responseRequired : true };
            }
        });

        function findErrorAtPosition(args, diags) {
            var startLine = args.startLine;
            var startCol = args.startOffset;
            var endLine = args.endLine || args.startLine;
            var endCol = args.endOffset || args.startOffset;
            for(var i = 0; i < diags.length; ++i) {
                var d = diags[i];
                var isAfterStart = (startLine > d.start.line) || (startLine == d.start.line && startCol >= d.start.offset);
                var isBeforeEnd  = (endLine < d.end.line) || (endLine == d.end.line && endCol <= d.end.offset);
                if (isAfterStart && isBeforeEnd) {
                    return d;
                }
            }
        };

        server.addProtocolHandler("codeFixAtPositionForVim", function(request) {
            var args = request.arguments;

            var codefixes = server.getSupportedCodeFixes();
            var diags = server.getSemanticDiagnosticsSync(args);

            var error = findErrorAtPosition(args, diags);
            if (error && codefixes.indexOf(error.code.toString()) != -1) {
                args.errorCodes = [error.code];
                return { response: server.getCodeFixes(args, true), responseRequired: true }
            }
            else {
                return { response: [], responseRequired: true };
            }
        });
    });
}
